{
  "project": "VST3MCPWrapper",
  "branchName": "ralph/code-review-3",
  "description": "Comprehensive Code Review â€” Fix memory ordering bug, harden thread safety, improve UTF-16 handling, consolidate logging, extract constants, deduplicate COM boilerplate, fill controller test coverage gaps, improve documentation accuracy",
  "userStories": [
    {
      "id": "US-001",
      "title": "Fix processorReady_ memory ordering (relaxed â†’ release/acquire)",
      "description": "As a developer, I want processorReady_ to use release/acquire memory ordering so that the audio thread is guaranteed to see the fully-constructed hostedProcessor_ when the flag becomes true.",
      "acceptanceCriteria": [
        "In processor.cpp loadHostedPlugin(), change `processorReady_.store(true, std::memory_order_relaxed)` to `std::memory_order_release`",
        "In processor.cpp process(), change `processorReady_.load(std::memory_order_relaxed)` to `std::memory_order_acquire`",
        "In processor.cpp unloadHostedPlugin(), change `processorReady_.store(false, std::memory_order_relaxed)` to `std::memory_order_release`",
        "All other reads of processorReady_ (e.g. in setState, notify handlers) should also use acquire â€” audit every .load() call site",
        "The hostedActive_/hostedProcessing_/wrapperActive_/wrapperProcessing_ flags remain relaxed (they are independent boolean flags, not publication guards)",
        "Update CLAUDE.md Threading Safety section to document that processorReady_ uses release/acquire while the other flags use relaxed, with a brief explanation of why",
        "Update ARCHITECTURE.md if it mentions processorReady_ memory ordering",
        "Build compiles without errors, all existing tests pass"
      ],
      "priority": 1,
      "passes": false,
      "notes": "processorReady_ is not just a flag â€” it's a publication guard. When the store becomes visible (true), the audio thread must also see the writes to hostedProcessor_, hostedComponent_, and all setup done in loadHostedPlugin(). memory_order_relaxed provides no such guarantee â€” the audio thread could see processorReady_=true but stale nullptr for hostedProcessor_. The release store synchronizes-with the acquire load, establishing a happens-before relationship. The other atomic bools (hostedActive_, hostedProcessing_, wrapperActive_, wrapperProcessing_) are simple independent flags that don't guard other non-atomic writes, so relaxed is correct for them. Search for ALL uses of processorReady_ with: grep -n 'processorReady_' source/processor.cpp source/processor.h"
    },
    {
      "id": "US-002",
      "title": "Use WRAPPER_LOG macros consistently (replace raw fprintf)",
      "description": "As a developer, I want all log output to go through the WRAPPER_LOG/WRAPPER_LOG_ERROR macros so that logging is consistent across platforms (os_log on macOS, stderr on Linux).",
      "acceptanceCriteria": [
        "Replace fprintf(stderr, ...) in hostedplugin.cpp pushParamChange() overflow warning with WRAPPER_LOG_ERROR(...)",
        "Replace fprintf(stderr, ...) in processor.cpp (null data pointer warning) with WRAPPER_LOG_ERROR(...)",
        "Search all source/*.cpp and source/*.mm files for any other raw fprintf(stderr, ...) calls and convert them to WRAPPER_LOG or WRAPPER_LOG_ERROR",
        "Include logging.h in any files that now use the macros but didn't before",
        "Verify the prefix format is consistent â€” all output should use '[VST3MCPWrapper]' prefix (the macros handle this)",
        "Build compiles without errors, all existing tests pass"
      ],
      "priority": 2,
      "passes": false,
      "notes": "Currently hostedplugin.cpp line 118 uses fprintf(stderr, 'VST3MCPWrapper: ...') with a colon prefix, while the WRAPPER_LOG macros use '[VST3MCPWrapper] ...' with brackets. The controller.cpp MCP server error handler (try-catch in start()) also uses fprintf. Search with: grep -rn 'fprintf(stderr' source/ â€” convert all hits to use the macros from logging.h. On macOS, this routes logs to os_log instead of stderr, which is the intended behavior. Don't touch test files â€” tests may use fprintf for their own output."
    },
    {
      "id": "US-003",
      "title": "Fix utf16ToUtf8 to handle surrogate pairs",
      "description": "As a developer, I want utf16ToUtf8() to correctly handle UTF-16 surrogate pairs so that plugin names and parameter names containing emoji or characters above U+FFFF are not silently corrupted.",
      "acceptanceCriteria": [
        "In hostedplugin.cpp utf16ToUtf8(), detect high surrogate (0xD800-0xDBFF) followed by low surrogate (0xDC00-0xDFFF) and decode the pair to a single code point above U+FFFF",
        "Encode code points above U+FFFF as 4-byte UTF-8 (0xF0 lead byte)",
        "Handle lone/orphaned surrogates gracefully (skip them or replace with U+FFFD replacement character)",
        "Add unit tests in test_utf16_conversion.cpp for: a basic surrogate pair (e.g. U+1F3B5 MUSICAL NOTE = D83C DFB5), a lone high surrogate, a lone low surrogate, and a string mixing BMP and supplementary characters",
        "Existing UTF-16 conversion tests still pass",
        "Build compiles without errors, all tests pass"
      ],
      "priority": 3,
      "passes": false,
      "notes": "The current implementation at hostedplugin.cpp:136-152 handles only BMP code points (up to 3-byte UTF-8). UTF-16 surrogate pairs encode code points U+10000-U+10FFFF as two 16-bit values: high surrogate (0xD800-0xDBFF) + low surrogate (0xDC00-0xDFFF). Formula: codepoint = 0x10000 + (high - 0xD800) * 0x400 + (low - 0xDC00). Then encode as 4-byte UTF-8: F0 xx xx xx. While VST3 plugin names rarely contain emoji, parameter names from creative plugins (e.g. ðŸŽµ) could. The existing test file test_utf16_conversion.cpp has tests for ASCII, German umlauts, CJK, empty strings, and max-length strings â€” add the surrogate pair tests alongside these."
    },
    {
      "id": "US-004",
      "title": "Extract dispatch timeout and MCP port as named constants",
      "description": "As a developer, I want magic literal values extracted to named constants so that policy values are documented and easy to change.",
      "acceptanceCriteria": [
        "Extract the 5-second dispatch timeout (used twice in controller.cpp for load_plugin and unload_plugin futures) to a named constexpr, e.g. `constexpr auto kDispatchTimeout = std::chrono::seconds(5)`",
        "The MCP server version string in controller.cpp should reference the kPluginVersion constant from version.h (or a dedicated MCP version constant if they should differ)",
        "Verify kMCPServerPort (already defined as constexpr) is used consistently â€” no other raw 8771 literals exist in source files",
        "Build compiles without errors, all existing tests pass"
      ],
      "priority": 4,
      "passes": false,
      "notes": "In controller.cpp, `std::chrono::seconds(5)` appears at lines 115 and 141 (load_plugin and unload_plugin tool handlers). These are the same policy â€” 'how long to wait for the main thread dispatcher to complete a load/unload.' A named constant makes the policy explicit and changeable in one place. The MCP server version at controller.cpp line 43 is hardcoded as '0.1.0' while version.h defines kPluginVersion. These should either be the same constant or explicitly separate with a comment explaining why. Search for other magic literals with: grep -rn 'seconds(' source/ and grep -rn '8771' source/"
    },
    {
      "id": "US-005",
      "title": "Deduplicate WrapperPlugView COM boilerplate into shared implementation",
      "description": "As a developer, I want the addRef/release/queryInterface boilerplate in WrapperPlugView to be defined once instead of duplicated between wrapperview.mm and wrapperview_linux.cpp.",
      "acceptanceCriteria": [
        "Move the addRef(), release(), and queryInterface() implementations into wrapperview.h (inline methods) or a new wrapperview_common.cpp",
        "Remove the duplicate implementations from wrapperview.mm and wrapperview_linux.cpp",
        "The refCount_ member (std::atomic<uint32>) should be declared in wrapperview.h if not already there",
        "Verify that addRef/release/queryInterface have identical logic in both platform files before deduplication â€” if there are differences, reconcile them",
        "If using inline methods in the header, ensure no ODR violations (templates or inline keyword)",
        "Build compiles without errors on Linux, all existing tests pass",
        "If wrapperview.mm is not compilable on Linux (it's Obj-C++), verify the deduplication doesn't break the macOS build by checking that wrapperview.h remains valid C++ (no Obj-C dependencies)"
      ],
      "priority": 5,
      "passes": false,
      "notes": "wrapperview.mm lines 315-342 and wrapperview_linux.cpp lines 105-132 contain identical addRef(), release(), and queryInterface() implementations. The WrapperPlugView class is already declared in wrapperview.h â€” the COM methods can be defined inline there since they don't depend on platform APIs. Check wrapperview.h first to see what's already declared there vs what's implemented in the .mm/.cpp files. Also check: tresult queryInterface(const TUID, void**), uint32 addRef(), uint32 release(). isPlatformTypeSupported(), attached(), removed(), onSize(), etc. are platform-specific and must remain in the .mm/.cpp files."
    },
    {
      "id": "US-006",
      "title": "Harden WrapperPlugView destructor against controller lifetime",
      "description": "As a developer, I want the WrapperPlugView destructor to safely handle the case where the Controller has already been destroyed, preventing a use-after-free write to controller_->activeView_.",
      "acceptanceCriteria": [
        "In the WrapperPlugView destructor, add a mechanism to detect that the controller is still alive before writing controller_->activeView_ = nullptr",
        "One approach: Controller::terminate() sets activeView_ = nullptr itself and sets a flag or clears the view's back-pointer â€” then the destructor checks before writing",
        "Another approach: use a weak_ptr or shared alive flag between Controller and WrapperPlugView",
        "Add a comment explaining the lifetime relationship: Controller creates WrapperPlugView, DAW owns the view's lifetime, Controller may be destroyed first during teardown",
        "Verify the fix works for both wrapperview_linux.cpp and wrapperview.mm (or the shared implementation after US-005)",
        "Build compiles without errors, all existing tests pass"
      ],
      "priority": 6,
      "passes": false,
      "notes": "The current destructor in wrapperview_linux.cpp line 12-14 and wrapperview.mm line 127-129 does `if (controller_) controller_->activeView_ = nullptr`. This guards against nullptr passed to the constructor, but NOT against the Controller being destroyed while the view still exists. In normal operation the DAW destroys views before the plugin, but during host crashes or unusual teardown orders this is a use-after-free. The simplest fix: have Controller::terminate() call `if (activeView_) activeView_->controller_ = nullptr;` to break the back-pointer. Then the destructor's existing null check becomes sufficient. This is a known pattern for COM observer pointers."
    },
    {
      "id": "US-007",
      "title": "Test Controller::createView lifecycle",
      "description": "As a developer, I want tests verifying that Controller::createView() returns a valid IPlugView and properly manages the activeView_ pointer.",
      "acceptanceCriteria": [
        "Test: createView('editor') returns a non-null IPlugView when no plugin is loaded (the drop zone view)",
        "Test: createView with an unsupported view type returns nullptr",
        "Test: the returned view implements queryInterface for IPlugView successfully",
        "Test: after createView, the controller's activeView_ is set to the returned view (use a friend accessor or verify indirectly)",
        "Test: creating a second view replaces the first (activeView_ updates)",
        "All tests in a new test file tests/test_controller_view.cpp or appended to test_controller_componenthandler.cpp",
        "Add new test file to tests/CMakeLists.txt if created",
        "Build compiles without errors, all tests pass"
      ],
      "priority": 7,
      "passes": false,
      "notes": "Controller::createView() is at controller.cpp line 220-228. It creates a WrapperPlugView (or returns the hosted view if a plugin is loaded). Testing without initialize() avoids MCP server startup â€” but createView may depend on some controller state. Check what createView actually needs. On Linux, WrapperPlugView::isPlatformTypeSupported returns kResultFalse (headless), but createView should still return a valid IPlugView object. The DAW calls isPlatformTypeSupported separately. Remember: do NOT call initialize() on the Controller in tests â€” it starts the MCP server. Access activeView_ via friend class if needed (WrapperPlugView is already a friend of Controller)."
    },
    {
      "id": "US-008",
      "title": "Test Controller::setComponentState (session restore path)",
      "description": "As a developer, I want tests verifying that Controller::setComponentState() correctly reads the wrapper state header and sets up the hosted controller when a plugin path is present.",
      "acceptanceCriteria": [
        "Test: setComponentState() with an empty plugin path (no hosted plugin in saved state) returns kResultOk without setting up a controller",
        "Test: setComponentState() with a valid state header containing a path calls setupHostedController() path (verify via side effect â€” e.g., getCurrentPluginPath() returns the path from state)",
        "Test: setComponentState() with a corrupt/invalid state header returns kResultFalse",
        "Test: setComponentState() with a null IBStream pointer returns kResultFalse",
        "All tests in tests/test_controller_state.cpp (new file) or appended to existing controller test file",
        "Add new test file to tests/CMakeLists.txt if created",
        "Build compiles without errors, all tests pass"
      ],
      "priority": 8,
      "passes": false,
      "notes": "Controller::setComponentState() reads the wrapper state format (magic, version, path) and if a plugin path is present, attempts to set up the hosted controller. On Linux without a real VST3 plugin, the setupHostedController path will fail at HostedPluginModule::load() â€” but we can still test: (1) the state parsing works, (2) empty path is handled gracefully, (3) corrupt state is rejected. Use writeStateHeader() from stateformat.h to create valid test state, and ResizableMemoryIBStream for the stream. The controller does NOT need initialize() for setComponentState to work â€” it reads from the stream and calls setupHostedController internally. Check controller.cpp to see what setComponentState actually does step by step."
    },
    {
      "id": "US-009",
      "title": "Improve setState error propagation on plugin load failure",
      "description": "As a developer, I want Processor::setState() to log a warning when loadHostedPlugin() fails during state restore, so that silent failures during preset recall are diagnosable.",
      "acceptanceCriteria": [
        "In Processor::setState(), check the return value of loadHostedPlugin(pluginPath)",
        "If loadHostedPlugin returns false, log a warning via WRAPPER_LOG_ERROR with the failed plugin path",
        "Do NOT change the return value of setState â€” it should still return kResultOk (the wrapper state itself was valid; the plugin just couldn't be loaded, and passthrough is the correct fallback)",
        "Skip replayDawStateOntoHosted() if loadHostedPlugin returned false (there's nothing to replay onto)",
        "Add a unit test: call setState with a valid header containing a nonexistent plugin path, verify it returns kResultOk and the processor is in passthrough mode (processorReady_ is false)",
        "Build compiles without errors, all tests pass"
      ],
      "priority": 9,
      "passes": false,
      "notes": "processor.cpp lines 300-308: loadHostedPlugin(pluginPath) is called but the bool return is discarded. If the load fails, replayDawStateOntoHosted() is called anyway (line 308) â€” this is harmless (hostedComponent_ is null, so replay is a no-op) but wasteful and confusing. The fix is simple: `bool loaded = loadHostedPlugin(pluginPath); if (!loaded) { WRAPPER_LOG_ERROR('...'); } else { replayDawStateOntoHosted(); }`. We do NOT want setState to return an error because the wrapper state header was valid â€” the DAW should not see an error for 'plugin not installed on this machine'. The existing test_processor_state.cpp has tests for setState â€” add the failure case there."
    },
    {
      "id": "US-010",
      "title": "Document undocumented architectural decisions",
      "description": "As a developer, I want CLAUDE.md and ARCHITECTURE.md to document currently-undocumented design decisions and known limitations discovered during this review.",
      "acceptanceCriteria": [
        "Document in CLAUDE.md that performEdit() deliberately does NOT forward to the DAW's componentHandler (parameter changes from hosted GUI bypass DAW automation recording) â€” add to Known Limitations or Architecture section",
        "Document in CLAUDE.md or ARCHITECTURE.md that the Linux MainThreadDispatcher is not actually the main thread (it's a dedicated worker thread) â€” clarify the naming vs actual behavior",
        "Document that activeView_ is a raw observer pointer with no lifetime guarantee beyond 'DAW destroys views before terminating plugins' convention",
        "Document that Processor and Controller each maintain separate currentPluginPath_ copies, and why (threading domains: processor's is on message thread, controller's is mutex-guarded for MCP access)",
        "Verify all source file descriptions in CLAUDE.md's Source Files table are still accurate â€” cross-check each entry against the actual file",
        "Update any test file listings if new test files were created in US-007 and US-008",
        "Build compiles without errors, all tests pass"
      ],
      "priority": 10,
      "passes": false,
      "notes": "This story captures documentation gaps found during the code review. The key undocumented decisions are: (1) performEdit not forwarding to DAW â€” this is intentional to avoid double-firing (the hosted plugin's own IComponentHandler call already goes to the DAW in the non-wrapped case, but in our wrapper we intercept it and only queue for the audio thread). (2) The 'MainThread' dispatcher naming is misleading on Linux â€” it's a worker thread, not the main thread. The macOS impl genuinely dispatches to the main thread via GCD. (3) activeView_ lifetime is fragile by design â€” COM observer pattern without ref-counting. (4) Dual currentPluginPath_ is necessary because the processor and controller operate on different threading domains. Review all changes from US-001 through US-009 to ensure nothing else needs documenting."
    }
  ]
}
